// Generated by CoffeeScript 1.9.1
window.onload = function() {
  var camera, centerMatrix, chunk_size, clock, container, delta, directionalLight, doWork, fNoiseScale, fRds, fRdsSin, generatedWorld, grid_geom, grid_mesh, grid_x, grid_y, i, iSize, j, k, l, landMaterial, light, m, manualWorld, myWorld, n, noise, ref, ref1, ref2, ref3, ref4, ref5, render, renderer, scene, waterMaterial, water_geom, water_height, water_mesh, x, y;
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  renderer = new THREE.WebGLRenderer({
    antialias: true
  });
  container = document.getElementById('threePanel');
  renderer.setSize(500, 500);
  container.appendChild(renderer.domElement);
  manualWorld = {
    water: 0.1,
    grid: [[0, 1, 0, 0], [0, 0, 0.5, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]
  };
  iSize = 31;
  fRds = iSize;
  fRdsSin = .5 * iSize / (2 * Math.PI);
  fNoiseScale = .3;
  noise = function(x, y) {
    var a, b, c, fNX, fNY, fRdx, fRdy, fYSin, v;
    fNX = (x + .5) / iSize;
    fNY = (y + .5) / iSize;
    fRdx = fNX * 2 * Math.PI;
    fRdy = fNY * Math.PI;
    fYSin = Math.sin(fRdy + Math.PI);
    a = fRdsSin * Math.sin(fRdx) * fYSin;
    b = fRdsSin * Math.cos(fRdx) * fYSin;
    c = fRdsSin * Math.cos(fRdy);
    v = Simplex.noise(123 + a * fNoiseScale, 132 + b * fNoiseScale, 312 + c * fNoiseScale);
    return v * 5;
  };
  chunk_size = 32;
  generatedWorld = {};
  generatedWorld.water = 2;
  generatedWorld.grid = [];
  for (x = i = 0, ref = chunk_size - 1; 0 <= ref ? i <= ref : i >= ref; x = 0 <= ref ? ++i : --i) {
    generatedWorld.grid[x] = [];
    for (y = j = 0, ref1 = chunk_size - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; y = 0 <= ref1 ? ++j : --j) {
      generatedWorld.grid[x][y] = noise(x, y);
    }
  }
  console.log(generatedWorld);
  landMaterial = new THREE.MeshLambertMaterial({
    wireframe: false,
    color: 0x00ff00
  });
  waterMaterial = new THREE.MeshLambertMaterial({
    wireframe: false,
    color: 0x0000ff
  });
  myWorld = generatedWorld;
  grid_y = myWorld.grid.length;
  grid_x = myWorld.grid[0].length;
  console.log("grid size is ", grid_x, grid_y);
  water_height = myWorld.water;
  console.log("water height is ", water_height);
  grid_geom = new THREE.Geometry();
  water_geom = new THREE.Geometry();
  for (y = k = 0, ref2 = grid_y - 1; 0 <= ref2 ? k <= ref2 : k >= ref2; y = 0 <= ref2 ? ++k : --k) {
    for (x = l = 0, ref3 = grid_x - 1; 0 <= ref3 ? l <= ref3 : l >= ref3; x = 0 <= ref3 ? ++l : --l) {
      grid_geom.vertices.push(new THREE.Vector3(x, y, myWorld.grid[y][x]));
      water_geom.vertices.push(new THREE.Vector3(x, y, water_height));
    }
  }
  for (y = m = 0, ref4 = grid_y - 2; 0 <= ref4 ? m <= ref4 : m >= ref4; y = 0 <= ref4 ? ++m : --m) {
    for (x = n = 0, ref5 = grid_x - 2; 0 <= ref5 ? n <= ref5 : n >= ref5; x = 0 <= ref5 ? ++n : --n) {
      grid_geom.faces.push(new THREE.Face3(y * grid_x + x, y * grid_x + x + 1, (y + 1) * grid_x + x));
      grid_geom.faces.push(new THREE.Face3(y * grid_x + x + 1, (y + 1) * grid_x + x + 1, (y + 1) * grid_x + x));
      water_geom.faces.push(new THREE.Face3(y * grid_x + x, y * grid_x + x + 1, (y + 1) * grid_x + x));
      water_geom.faces.push(new THREE.Face3(y * grid_x + x + 1, (y + 1) * grid_x + x + 1, (y + 1) * grid_x + x));
    }
  }
  grid_geom.computeBoundingSphere();
  grid_geom.computeFaceNormals();
  grid_geom.computeVertexNormals();
  water_geom.computeBoundingSphere();
  water_geom.computeFaceNormals();
  water_geom.computeVertexNormals();
  grid_mesh = new THREE.Mesh(grid_geom, landMaterial);
  water_mesh = new THREE.Mesh(water_geom, waterMaterial);
  centerMatrix = new THREE.Matrix4().makeTranslation(-grid_x / 2, -grid_y / 2, 0);
  grid_mesh.geometry.applyMatrix(centerMatrix);
  water_mesh.geometry.applyMatrix(centerMatrix);
  scene.add(grid_mesh);
  scene.add(water_mesh);
  clock = new THREE.Clock();
  grid_mesh.rotation.x = -Math.PI / 2;
  water_mesh.rotation.x = -Math.PI / 2;
  camera.position.z = 18;
  camera.position.y = 7;
  camera.rotation.x = -Math.PI / 8;
  light = new THREE.AmbientLight(0x101010);
  scene.add(light);
  directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
  directionalLight.position.set(0, .5, 0);
  scene.add(directionalLight);
  delta = 0;
  doWork = function() {
    var axis;
    delta = clock.getDelta();
    axis = new THREE.Vector3(0, 0, 1);
    grid_mesh.rotateOnAxis(axis, Math.PI * delta / 5);
    return water_mesh.rotateOnAxis(axis, Math.PI * delta / 5);
  };
  render = function() {
    requestAnimationFrame(render);
    doWork();
    return renderer.render(scene, camera);
  };
  return render();
};
